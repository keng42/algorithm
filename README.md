# algorithm
一些常见算法的 Java 实现

排序算法：快速排序，堆排序，归并排序  
搜索算法：二分查找，深度优先搜索，广度优先搜索  
字符串匹配：KMP  
最小生成树：Prim，Kruskal  
最短路径：Dijkstra  

## 排序算法
### 快速排序
快速排序采用分治法策略，递归的地把一个数组以选定的一个数为基准分为两个数组，递归的终点是数组的长度小于等于1。  
1. 从数组中挑选一个元素，称为'基准'  
2. 分区：把大于基准的元素移动到右边，小的移动到左边，最终把基准移动到中间  
3. 递归地把大小两个数组都进行分区，数组小于2时递归结束  

### 堆排序
堆起始是个完全二叉树，分为大顶堆和小顶堆。堆又分为无序区和有序区。  
1. 构造初始堆  
2. 遍历堆，每次将无序区构造为大顶堆，然后将大顶加入有序区，直到无序区为空  

### 归并排序
递归地将数组平均分为两组然后分别进行排序，然后合并两个数组。递归的终点是数组只有一个元素。  
1. 将数组平均分为两组数组  
2. 递归调用本身，分别对两组数组再分组直到只有一个元素  
3. 合并数组  

## 搜索算法
### 二分查找
在一个有序数组中查找某个元素，每次对比数组中点元素，根据中点大小确定新的中点。
### DFS
借助堆栈实现  
### BFS
借助队列实现 

## 最小生成树
### Prim
新建一个空的点集和边集，首先将选取任意一个点加入点集中。找到可选的最小的边加入边集中，直到所有点都已加入点集中。可选的最小边指的是：点集中的点作为起始点并且终点不属于点集的所有边，这样保证了不会形成回路，按权重取最小的边。  
### Kruskal
新建一个包含所有节点但无边的新图，生成按权重从小到大排序的边集，遍历所有边，若边的两个节点不属于同一通路，则将该边加入新图中。判断两节点是否属于同一通路的方法是用一个数组存储每个节点的上一个节点，从而可以得知新图中该节点所属通路的尾节点，若得到的两个尾节点不同，则该两个节点不属同一通路，将该边加入新图后需在此数组中连接两个尾节点表示原来的两条通路现在属于一条通路。  

## 最短路径
### Dijkstra
从开始节点开始广度优先遍历下一层所有未处理节点，计算从开始节点到该相关节点的最短路径长度，直到所有节点都处理完。节点是否已处理：从待处理队列中取出并遍历完下一层相关节点的路径长度即为处理完（从开始节点往下走不往上一层走）。处理指的是：处理当前节点时，计算到下一层节点的路径与原有路径对比取小的保存为下一层节点的路径长度。  
